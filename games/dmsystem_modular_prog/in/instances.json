{"experiments": [{"name": "restaurant", "game_instances": [{"game_id": 0, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}, "name": {"type": "string"}, "food": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "bookday": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "bookpeople": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "booktime": {"type": "string"}, "food": {"type": "string"}, "name": {"type": "string"}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}}, "required": ["area", "bookday", "bookpeople", "booktime", "food", "name", "pricerange"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "restaurant", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/restaurant-dbase.db", "domain_schema": {"restaurant": {"service_name": "restaurant", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["cheap", "expensive", "moderate"]}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "food", "is_categorical": false, "possible_values": []}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "booktime", "is_categorical": false, "possible_values": []}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "find places to dine and whet your appetite", "intents": [{"name": "find_restaurant", "description": "search for places to wine and dine", "is_transactional": false, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}, {"name": "book_restaurant", "description": "book a table at a restaurant", "is_transactional": true, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}]}}, "goal": "I'm looking for a cheap place to dine, preferably in the centre of town.", "slots": {"area": "centre", "bookday": "friday", "bookpeople": "4", "booktime": "14:15", "food": "chinese", "name": "charlie chan", "pricerange": "cheap"}, "cat_slots": ["pricerange", "area", "bookday", "bookpeople"], "noncat_slots": ["food", "name", "booktime", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "food"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a restaurant booking system.\n\nTASK:\nI'm looking for a cheap place to dine, preferably in the centre of town.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'area': 'centre', 'bookday': 'friday', 'bookpeople': '4', 'booktime': '14:15', 'food': 'chinese', 'name': 'charlie chan', 'pricerange': 'cheap'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'area': 'centre', 'bookday': 'friday', 'bookpeople': '4', 'booktime': '14:15', 'food': 'chinese', 'name': 'charlie chan', 'pricerange': 'cheap'}\n\nHere is the restaurant booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a restaurant booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['area', 'bookday', 'bookpeople', 'booktime', 'food', 'name', 'pricerange']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['area', 'bookday', 'bookpeople', 'booktime', 'food', 'name', 'pricerange']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}, 'name': {'type': 'string'}, 'food': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'bookday': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'bookpeople': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'booktime': {'type': 'string'}, 'food': {'type': 'string'}, 'name': {'type': 'string'}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 1, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}, "name": {"type": "string"}, "food": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"food": {"type": "string"}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}}, "required": ["food", "pricerange"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "restaurant", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/restaurant-dbase.db", "domain_schema": {"restaurant": {"service_name": "restaurant", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["cheap", "expensive", "moderate"]}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "food", "is_categorical": false, "possible_values": []}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "booktime", "is_categorical": false, "possible_values": []}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "find places to dine and whet your appetite", "intents": [{"name": "find_restaurant", "description": "search for places to wine and dine", "is_transactional": false, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}, {"name": "book_restaurant", "description": "book a table at a restaurant", "is_transactional": true, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}]}}, "goal": "I am looking for a place to dine. The restaurant should be in the cheap price range and should serve chinese food", "slots": {"food": "chinese", "pricerange": "cheap"}, "cat_slots": ["pricerange", "area", "bookday", "bookpeople"], "noncat_slots": ["food", "name", "booktime", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "food"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a restaurant booking system.\n\nTASK:\nI am looking for a place to dine. The restaurant should be in the cheap price range and should serve chinese food\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'food': 'chinese', 'pricerange': 'cheap'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'food': 'chinese', 'pricerange': 'cheap'}\n\nHere is the restaurant booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a restaurant booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['food', 'pricerange']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['food', 'pricerange']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}, 'name': {'type': 'string'}, 'food': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'food': {'type': 'string'}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 2, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}, "name": {"type": "string"}, "food": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"bookday": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "bookpeople": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "booktime": {"type": "string"}, "name": {"type": "string"}}, "required": ["bookday", "bookpeople", "booktime", "name"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "restaurant", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/restaurant-dbase.db", "domain_schema": {"restaurant": {"service_name": "restaurant", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["cheap", "expensive", "moderate"]}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "food", "is_categorical": false, "possible_values": []}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "booktime", "is_categorical": false, "possible_values": []}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "find places to dine and whet your appetite", "intents": [{"name": "find_restaurant", "description": "search for places to wine and dine", "is_transactional": false, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}, {"name": "book_restaurant", "description": "book a table at a restaurant", "is_transactional": true, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}]}}, "goal": "Could you give me information about a restaurant called panahar?", "slots": {"bookday": "friday", "bookpeople": "4", "booktime": "10:00", "name": "panahar"}, "cat_slots": ["pricerange", "area", "bookday", "bookpeople"], "noncat_slots": ["food", "name", "booktime", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "food"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a restaurant booking system.\n\nTASK:\nCould you give me information about a restaurant called panahar?\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'friday', 'bookpeople': '4', 'booktime': '10:00', 'name': 'panahar'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'friday', 'bookpeople': '4', 'booktime': '10:00', 'name': 'panahar'}\n\nHere is the restaurant booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a restaurant booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['bookday', 'bookpeople', 'booktime', 'name']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['bookday', 'bookpeople', 'booktime', 'name']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}, 'name': {'type': 'string'}, 'food': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'bookday': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'bookpeople': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'booktime': {'type': 'string'}, 'name': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 3, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}, "name": {"type": "string"}, "food": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"food": {"type": "string"}, "name": {"type": "string"}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}}, "required": ["food", "name", "pricerange"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "restaurant", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/restaurant-dbase.db", "domain_schema": {"restaurant": {"service_name": "restaurant", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["cheap", "expensive", "moderate"]}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "food", "is_categorical": false, "possible_values": []}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "booktime", "is_categorical": false, "possible_values": []}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "find places to dine and whet your appetite", "intents": [{"name": "find_restaurant", "description": "search for places to wine and dine", "is_transactional": false, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}, {"name": "book_restaurant", "description": "book a table at a restaurant", "is_transactional": true, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}]}}, "goal": "I'd like to find a place that I can get some Northern European food.", "slots": {"food": "modern european", "name": "de luca cucina and bar luca cucina", "pricerange": "moderate"}, "cat_slots": ["pricerange", "area", "bookday", "bookpeople"], "noncat_slots": ["food", "name", "booktime", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "food"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a restaurant booking system.\n\nTASK:\nI'd like to find a place that I can get some Northern European food.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'food': 'modern european', 'name': 'de luca cucina and bar luca cucina', 'pricerange': 'moderate'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'food': 'modern european', 'name': 'de luca cucina and bar luca cucina', 'pricerange': 'moderate'}\n\nHere is the restaurant booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a restaurant booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['food', 'name', 'pricerange']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['food', 'name', 'pricerange']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}, 'name': {'type': 'string'}, 'food': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'food': {'type': 'string'}, 'name': {'type': 'string'}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 4, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}, "name": {"type": "string"}, "food": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "name": {"type": "string"}, "pricerange": {"type": "string", "enum": ["cheap", "expensive", "moderate"]}}, "required": ["area", "name", "pricerange"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "restaurant", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/restaurant-dbase.db", "domain_schema": {"restaurant": {"service_name": "restaurant", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["cheap", "expensive", "moderate"]}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "food", "is_categorical": false, "possible_values": []}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "booktime", "is_categorical": false, "possible_values": []}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "find places to dine and whet your appetite", "intents": [{"name": "find_restaurant", "description": "search for places to wine and dine", "is_transactional": false, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}, {"name": "book_restaurant", "description": "book a table at a restaurant", "is_transactional": true, "required_slots": [], "optional_slots": {"restaurant-pricerange": "dontcare", "restaurant-area": "dontcare", "restaurant-food": "dontcare", "restaurant-name": "dontcare", "restaurant-bookday": "dontcare", "restaurant-bookpeople": "dontcare", "restaurant-booktime": "dontcare"}}]}}, "goal": "Hi, I am looking for an expensive restaurant in the east.", "slots": {"area": "east", "name": "royal standard", "pricerange": "expensive"}, "cat_slots": ["pricerange", "area", "bookday", "bookpeople"], "noncat_slots": ["food", "name", "booktime", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "food"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a restaurant booking system.\n\nTASK:\nHi, I am looking for an expensive restaurant in the east.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'area': 'east', 'name': 'royal standard', 'pricerange': 'expensive'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'area': 'east', 'name': 'royal standard', 'pricerange': 'expensive'}\n\nHere is the restaurant booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a restaurant booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['area', 'name', 'pricerange']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['area', 'name', 'pricerange']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}, 'name': {'type': 'string'}, 'food': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'name': {'type': 'string'}, 'pricerange': {'type': 'string', 'enum': ['cheap', 'expensive', 'moderate']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}]}, {"name": "hotel", "game_instances": [{"game_id": 0, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "name": {"type": "string"}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}, "type": {"type": "string", "enum": ["guesthouse", "hotel"]}, "internet": {"type": "string", "enum": ["yes", "no"]}, "parking": {"type": "string", "enum": ["yes", "no"]}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"bookday": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "bookpeople": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "bookstay": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "name": {"type": "string"}}, "required": ["bookday", "bookpeople", "bookstay", "name"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "hotel", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/hotel-dbase.db", "domain_schema": {"hotel": {"service_name": "hotel", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["expensive", "cheap", "moderate"]}, {"name": "type", "is_categorical": true, "possible_values": ["guesthouse", "hotel"]}, {"name": "parking", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "bookstay", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "stars", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5"]}, {"name": "internet", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "hotel reservations and vacation stays", "intents": [{"name": "find_hotel", "description": "search for a hotel to stay in", "is_transactional": false, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}, {"name": "book_hotel", "description": "book a hotel to stay in", "is_transactional": true, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}]}}, "goal": "Can you look up a hotel called Cityroomz?", "slots": {"bookday": "tuesday", "bookpeople": "6", "bookstay": "4", "name": "cityroomz"}, "cat_slots": ["pricerange", "type", "parking", "bookday", "bookpeople", "bookstay", "stars", "internet", "area"], "noncat_slots": ["name", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "stars", "type", "internet", "parking"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a hotel booking system.\n\nTASK:\nCan you look up a hotel called Cityroomz?\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'tuesday', 'bookpeople': '6', 'bookstay': '4', 'name': 'cityroomz'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'tuesday', 'bookpeople': '6', 'bookstay': '4', 'name': 'cityroomz'}\n\nHere is the hotel booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a hotel booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['bookday', 'bookpeople', 'bookstay', 'name']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['bookday', 'bookpeople', 'bookstay', 'name']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'name': {'type': 'string'}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}, 'type': {'type': 'string', 'enum': ['guesthouse', 'hotel']}, 'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'bookday': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'bookpeople': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'bookstay': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'name': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 1, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "name": {"type": "string"}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}, "type": {"type": "string", "enum": ["guesthouse", "hotel"]}, "internet": {"type": "string", "enum": ["yes", "no"]}, "parking": {"type": "string", "enum": ["yes", "no"]}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"bookday": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "bookpeople": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "bookstay": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "internet": {"type": "string", "enum": ["yes", "no"]}, "name": {"type": "string"}, "parking": {"type": "string", "enum": ["yes", "no"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}}, "required": ["bookday", "bookpeople", "bookstay", "internet", "name", "parking", "pricerange", "stars"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "hotel", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/hotel-dbase.db", "domain_schema": {"hotel": {"service_name": "hotel", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["expensive", "cheap", "moderate"]}, {"name": "type", "is_categorical": true, "possible_values": ["guesthouse", "hotel"]}, {"name": "parking", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "bookstay", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "stars", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5"]}, {"name": "internet", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "hotel reservations and vacation stays", "intents": [{"name": "find_hotel", "description": "search for a hotel to stay in", "is_transactional": false, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}, {"name": "book_hotel", "description": "book a hotel to stay in", "is_transactional": true, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}]}}, "goal": "Could you find a moderate priced place to stay for me? I do need free WiFi.", "slots": {"bookday": "tuesday", "bookpeople": "4", "bookstay": "2", "internet": "yes", "name": "ashley hotel", "parking": "yes", "pricerange": "moderate", "stars": "2"}, "cat_slots": ["pricerange", "type", "parking", "bookday", "bookpeople", "bookstay", "stars", "internet", "area"], "noncat_slots": ["name", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "stars", "type", "internet", "parking"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a hotel booking system.\n\nTASK:\nCould you find a moderate priced place to stay for me? I do need free WiFi.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'tuesday', 'bookpeople': '4', 'bookstay': '2', 'internet': 'yes', 'name': 'ashley hotel', 'parking': 'yes', 'pricerange': 'moderate', 'stars': '2'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'tuesday', 'bookpeople': '4', 'bookstay': '2', 'internet': 'yes', 'name': 'ashley hotel', 'parking': 'yes', 'pricerange': 'moderate', 'stars': '2'}\n\nHere is the hotel booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a hotel booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['bookday', 'bookpeople', 'bookstay', 'internet', 'name', 'parking', 'pricerange', 'stars']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['bookday', 'bookpeople', 'bookstay', 'internet', 'name', 'parking', 'pricerange', 'stars']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'name': {'type': 'string'}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}, 'type': {'type': 'string', 'enum': ['guesthouse', 'hotel']}, 'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'bookday': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'bookpeople': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'bookstay': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'name': {'type': 'string'}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 2, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "name": {"type": "string"}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}, "type": {"type": "string", "enum": ["guesthouse", "hotel"]}, "internet": {"type": "string", "enum": ["yes", "no"]}, "parking": {"type": "string", "enum": ["yes", "no"]}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"bookday": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "bookpeople": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "bookstay": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "name": {"type": "string"}}, "required": ["bookday", "bookpeople", "bookstay", "name"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "hotel", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/hotel-dbase.db", "domain_schema": {"hotel": {"service_name": "hotel", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["expensive", "cheap", "moderate"]}, {"name": "type", "is_categorical": true, "possible_values": ["guesthouse", "hotel"]}, {"name": "parking", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "bookstay", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "stars", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5"]}, {"name": "internet", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "hotel reservations and vacation stays", "intents": [{"name": "find_hotel", "description": "search for a hotel to stay in", "is_transactional": false, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}, {"name": "book_hotel", "description": "book a hotel to stay in", "is_transactional": true, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}]}}, "goal": "I'm looking for a hotel called the Arbury Lodge Guesthouse. Do you have a listing for this?", "slots": {"bookday": "monday", "bookpeople": "8", "bookstay": "5", "name": "super 5"}, "cat_slots": ["pricerange", "type", "parking", "bookday", "bookpeople", "bookstay", "stars", "internet", "area"], "noncat_slots": ["name", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "stars", "type", "internet", "parking"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a hotel booking system.\n\nTASK:\nI'm looking for a hotel called the Arbury Lodge Guesthouse. Do you have a listing for this?\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'monday', 'bookpeople': '8', 'bookstay': '5', 'name': 'super 5'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'monday', 'bookpeople': '8', 'bookstay': '5', 'name': 'super 5'}\n\nHere is the hotel booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a hotel booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['bookday', 'bookpeople', 'bookstay', 'name']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['bookday', 'bookpeople', 'bookstay', 'name']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'name': {'type': 'string'}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}, 'type': {'type': 'string', 'enum': ['guesthouse', 'hotel']}, 'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'bookday': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'bookpeople': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'bookstay': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'name': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 3, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "name": {"type": "string"}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}, "type": {"type": "string", "enum": ["guesthouse", "hotel"]}, "internet": {"type": "string", "enum": ["yes", "no"]}, "parking": {"type": "string", "enum": ["yes", "no"]}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"bookday": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "bookpeople": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "bookstay": {"type": "string", "enum": ["1", "2", "3", "4", "5", "6", "7", "8"]}, "name": {"type": "string"}, "parking": {"type": "string", "enum": ["yes", "no"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}}, "required": ["bookday", "bookpeople", "bookstay", "name", "parking", "pricerange", "stars"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "hotel", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/hotel-dbase.db", "domain_schema": {"hotel": {"service_name": "hotel", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["expensive", "cheap", "moderate"]}, {"name": "type", "is_categorical": true, "possible_values": ["guesthouse", "hotel"]}, {"name": "parking", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "bookstay", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "stars", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5"]}, {"name": "internet", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "hotel reservations and vacation stays", "intents": [{"name": "find_hotel", "description": "search for a hotel to stay in", "is_transactional": false, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}, {"name": "book_hotel", "description": "book a hotel to stay in", "is_transactional": true, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}]}}, "goal": "I'm looking for a hotel with free parking.", "slots": {"bookday": "wednesday", "bookpeople": "4", "bookstay": "4", "name": "kirkwood house", "parking": "yes", "pricerange": "moderate", "stars": "4"}, "cat_slots": ["pricerange", "type", "parking", "bookday", "bookpeople", "bookstay", "stars", "internet", "area"], "noncat_slots": ["name", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "stars", "type", "internet", "parking"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a hotel booking system.\n\nTASK:\nI'm looking for a hotel with free parking.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'wednesday', 'bookpeople': '4', 'bookstay': '4', 'name': 'kirkwood house', 'parking': 'yes', 'pricerange': 'moderate', 'stars': '4'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookday': 'wednesday', 'bookpeople': '4', 'bookstay': '4', 'name': 'kirkwood house', 'parking': 'yes', 'pricerange': 'moderate', 'stars': '4'}\n\nHere is the hotel booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a hotel booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['bookday', 'bookpeople', 'bookstay', 'name', 'parking', 'pricerange', 'stars']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['bookday', 'bookpeople', 'bookstay', 'name', 'parking', 'pricerange', 'stars']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'name': {'type': 'string'}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}, 'type': {'type': 'string', 'enum': ['guesthouse', 'hotel']}, 'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'bookday': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'bookpeople': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'bookstay': {'type': 'string', 'enum': ['1', '2', '3', '4', '5', '6', '7', '8']}, 'name': {'type': 'string'}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 4, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"area": {"type": "string", "enum": ["centre", "east", "north", "south", "west"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "name": {"type": "string"}, "stars": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5"]}, "type": {"type": "string", "enum": ["guesthouse", "hotel"]}, "internet": {"type": "string", "enum": ["yes", "no"]}, "parking": {"type": "string", "enum": ["yes", "no"]}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"internet": {"type": "string", "enum": ["yes", "no"]}, "pricerange": {"type": "string", "enum": ["expensive", "cheap", "moderate"]}, "type": {"type": "string", "enum": ["guesthouse", "hotel"]}}, "required": ["internet", "pricerange", "type"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "hotel", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/hotel-dbase.db", "domain_schema": {"hotel": {"service_name": "hotel", "slots": [{"name": "pricerange", "is_categorical": true, "possible_values": ["expensive", "cheap", "moderate"]}, {"name": "type", "is_categorical": true, "possible_values": ["guesthouse", "hotel"]}, {"name": "parking", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "bookday", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "bookstay", "is_categorical": true, "possible_values": ["1", "2", "3", "4", "5", "6", "7", "8"]}, {"name": "stars", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5"]}, {"name": "internet", "is_categorical": true, "possible_values": ["free", "no", "yes"]}, {"name": "name", "is_categorical": false, "possible_values": []}, {"name": "area", "is_categorical": true, "possible_values": ["centre", "east", "north", "south", "west"]}, {"name": "address", "is_categorical": false, "possible_values": []}, {"name": "phone", "is_categorical": false, "possible_values": []}, {"name": "postcode", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}], "description": "hotel reservations and vacation stays", "intents": [{"name": "find_hotel", "description": "search for a hotel to stay in", "is_transactional": false, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}, {"name": "book_hotel", "description": "book a hotel to stay in", "is_transactional": true, "required_slots": [], "optional_slots": {"hotel-pricerange": "dontcare", "hotel-type": "dontcare", "hotel-parking": "dontcare", "hotel-bookday": "dontcare", "hotel-bookpeople": "dontcare", "hotel-bookstay": "dontcare", "hotel-stars": "dontcare", "hotel-internet": "dontcare", "hotel-name": "dontcare", "hotel-area": "dontcare"}}]}}, "goal": "Good evening. Can you help me find a guesthouse to stay at for the weekend?", "slots": {"internet": "yes", "pricerange": "moderate", "type": "guesthouse"}, "cat_slots": ["pricerange", "type", "parking", "bookday", "bookpeople", "bookstay", "stars", "internet", "area"], "noncat_slots": ["name", "address", "phone", "postcode", "ref"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["area", "pricerange", "name", "stars", "type", "internet", "parking"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a hotel booking system.\n\nTASK:\nGood evening. Can you help me find a guesthouse to stay at for the weekend?\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'internet': 'yes', 'pricerange': 'moderate', 'type': 'guesthouse'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'internet': 'yes', 'pricerange': 'moderate', 'type': 'guesthouse'}\n\nHere is the hotel booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a hotel booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['internet', 'pricerange', 'type']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['internet', 'pricerange', 'type']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'area': {'type': 'string', 'enum': ['centre', 'east', 'north', 'south', 'west']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'name': {'type': 'string'}, 'stars': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5']}, 'type': {'type': 'string', 'enum': ['guesthouse', 'hotel']}, 'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'parking': {'type': 'string', 'enum': ['yes', 'no']}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'internet': {'type': 'string', 'enum': ['yes', 'no']}, 'pricerange': {'type': 'string', 'enum': ['expensive', 'cheap', 'moderate']}, 'type': {'type': 'string', 'enum': ['guesthouse', 'hotel']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}]}, {"name": "train", "game_instances": [{"game_id": 0, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "arriveby": {"type": "string"}, "leaveat": {"type": "string"}, "duration": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"arriveby": {"type": "string"}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}}, "required": ["arriveby", "day", "departure", "destination"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "train", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/train-dbase.db", "domain_schema": {"train": {"service_name": "train", "slots": [{"name": "arriveby", "is_categorical": false, "possible_values": []}, {"name": "departure", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "day", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, {"name": "leaveat", "is_categorical": false, "possible_values": []}, {"name": "destination", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "trainid", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}, {"name": "price", "is_categorical": false, "possible_values": []}, {"name": "duration", "is_categorical": false, "possible_values": []}], "description": "find trains that take you to places", "intents": [{"name": "find_train", "description": "search for trains that take you places", "is_transactional": false, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}, {"name": "book_train", "description": "book train tickets", "is_transactional": true, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}]}}, "goal": "Hi, I'm looking for train information. It needs to leave on Sunday and arrive at or around 20:45.", "slots": {"arriveby": "20:45", "day": "sunday", "departure": "cambridge", "destination": "leicester"}, "cat_slots": ["departure", "day", "bookpeople", "destination"], "noncat_slots": ["arriveby", "leaveat", "trainid", "ref", "price", "duration"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["destination", "day", "departure", "arriveby", "leaveat", "duration"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a train booking system.\n\nTASK:\nHi, I'm looking for train information. It needs to leave on Sunday and arrive at or around 20:45.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '20:45', 'day': 'sunday', 'departure': 'cambridge', 'destination': 'leicester'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '20:45', 'day': 'sunday', 'departure': 'cambridge', 'destination': 'leicester'}\n\nHere is the train booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a train booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['arriveby', 'day', 'departure', 'destination']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['arriveby', 'day', 'departure', 'destination']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'arriveby': {'type': 'string'}, 'leaveat': {'type': 'string'}, 'duration': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'arriveby': {'type': 'string'}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 1, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "arriveby": {"type": "string"}, "leaveat": {"type": "string"}, "duration": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"arriveby": {"type": "string"}, "bookpeople": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}}, "required": ["arriveby", "bookpeople", "day", "departure", "destination"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "train", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/train-dbase.db", "domain_schema": {"train": {"service_name": "train", "slots": [{"name": "arriveby", "is_categorical": false, "possible_values": []}, {"name": "departure", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "day", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, {"name": "leaveat", "is_categorical": false, "possible_values": []}, {"name": "destination", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "trainid", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}, {"name": "price", "is_categorical": false, "possible_values": []}, {"name": "duration", "is_categorical": false, "possible_values": []}], "description": "find trains that take you to places", "intents": [{"name": "find_train", "description": "search for trains that take you places", "is_transactional": false, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}, {"name": "book_train", "description": "book train tickets", "is_transactional": true, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}]}}, "goal": "Hi there, I'm looking for a train going to cambridge.", "slots": {"arriveby": "14:00", "bookpeople": "2", "day": "tuesday", "departure": "bishops stortford", "destination": "cambridge"}, "cat_slots": ["departure", "day", "bookpeople", "destination"], "noncat_slots": ["arriveby", "leaveat", "trainid", "ref", "price", "duration"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["destination", "day", "departure", "arriveby", "leaveat", "duration"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a train booking system.\n\nTASK:\nHi there, I'm looking for a train going to cambridge.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '14:00', 'bookpeople': '2', 'day': 'tuesday', 'departure': 'bishops stortford', 'destination': 'cambridge'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '14:00', 'bookpeople': '2', 'day': 'tuesday', 'departure': 'bishops stortford', 'destination': 'cambridge'}\n\nHere is the train booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a train booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['arriveby', 'bookpeople', 'day', 'departure', 'destination']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['arriveby', 'bookpeople', 'day', 'departure', 'destination']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'arriveby': {'type': 'string'}, 'leaveat': {'type': 'string'}, 'duration': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'arriveby': {'type': 'string'}, 'bookpeople': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '15']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 2, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "arriveby": {"type": "string"}, "leaveat": {"type": "string"}, "duration": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"bookpeople": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "leaveat": {"type": "string"}}, "required": ["bookpeople", "day", "departure", "leaveat"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "train", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/train-dbase.db", "domain_schema": {"train": {"service_name": "train", "slots": [{"name": "arriveby", "is_categorical": false, "possible_values": []}, {"name": "departure", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "day", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, {"name": "leaveat", "is_categorical": false, "possible_values": []}, {"name": "destination", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "trainid", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}, {"name": "price", "is_categorical": false, "possible_values": []}, {"name": "duration", "is_categorical": false, "possible_values": []}], "description": "find trains that take you to places", "intents": [{"name": "find_train", "description": "search for trains that take you places", "is_transactional": false, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}, {"name": "book_train", "description": "book train tickets", "is_transactional": true, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}]}}, "goal": "I am looking for a train departing from Stevenage.", "slots": {"bookpeople": "1", "day": "tuesday", "departure": "stevenage", "leaveat": "20:30"}, "cat_slots": ["departure", "day", "bookpeople", "destination"], "noncat_slots": ["arriveby", "leaveat", "trainid", "ref", "price", "duration"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["destination", "day", "departure", "arriveby", "leaveat", "duration"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a train booking system.\n\nTASK:\nI am looking for a train departing from Stevenage.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookpeople': '1', 'day': 'tuesday', 'departure': 'stevenage', 'leaveat': '20:30'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'bookpeople': '1', 'day': 'tuesday', 'departure': 'stevenage', 'leaveat': '20:30'}\n\nHere is the train booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a train booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['bookpeople', 'day', 'departure', 'leaveat']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['bookpeople', 'day', 'departure', 'leaveat']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'arriveby': {'type': 'string'}, 'leaveat': {'type': 'string'}, 'duration': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'bookpeople': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '15']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'leaveat': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 3, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "arriveby": {"type": "string"}, "leaveat": {"type": "string"}, "duration": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"arriveby": {"type": "string"}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}}, "required": ["arriveby", "day", "departure"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "train", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/train-dbase.db", "domain_schema": {"train": {"service_name": "train", "slots": [{"name": "arriveby", "is_categorical": false, "possible_values": []}, {"name": "departure", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "day", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, {"name": "leaveat", "is_categorical": false, "possible_values": []}, {"name": "destination", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "trainid", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}, {"name": "price", "is_categorical": false, "possible_values": []}, {"name": "duration", "is_categorical": false, "possible_values": []}], "description": "find trains that take you to places", "intents": [{"name": "find_train", "description": "search for trains that take you places", "is_transactional": false, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}, {"name": "book_train", "description": "book train tickets", "is_transactional": true, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}]}}, "goal": "i am looking for a train from london kings cross and leaves on wednesday", "slots": {"arriveby": "13:30", "day": "wednesday", "departure": "london kings cross"}, "cat_slots": ["departure", "day", "bookpeople", "destination"], "noncat_slots": ["arriveby", "leaveat", "trainid", "ref", "price", "duration"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["destination", "day", "departure", "arriveby", "leaveat", "duration"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a train booking system.\n\nTASK:\ni am looking for a train from london kings cross and leaves on wednesday\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '13:30', 'day': 'wednesday', 'departure': 'london kings cross'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '13:30', 'day': 'wednesday', 'departure': 'london kings cross'}\n\nHere is the train booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a train booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['arriveby', 'day', 'departure']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['arriveby', 'day', 'departure']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'arriveby': {'type': 'string'}, 'leaveat': {'type': 'string'}, 'duration': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'arriveby': {'type': 'string'}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}, {"game_id": 4, "data": {"n_turns": 10, "similarity": {"threshold": 70}, "liberal_processing": true, "statusmsg": {"welcome": "Welcome to the $domain booking bot. Let me know, how can I help you?", "usergoal": "SaveGoal:\nBegin your interaction with the bot by exactly stating the below mentioned goal:\nGoal:\n$goal\n\nFollow-up with the bot to achieve the goal.", "dmresponse": "$response", "no_booking": "The game has started. You are the first player.", "no_slots": "The game has ended. Thank you for playing.", "no_domain": "domain info is not available", "no_key_match": "none of the keys are matched", "partial_key_match": "only some of the keys are matched", "no_value_match": "keys are matched but none of the values are matched", "partial_value_match": "for some keys, values are matched", "unknown": "unknown error", "success": "Success", "failure": "Failure", "dbfetch": "in fetching the data from the database.", "validatebooking": "in booking.", "availablecolumns": "The available columns are: $columns", "missing_slots": "The missing arguments are: $slots", "invalid_value": "The value(s) for  the $slot are not matching with the booking system.", "booking_reference": "Your booking reference number is $refnum.", "nocolumnmatch": "No matching columns found in the database.", "novaluematch": "No matching data found in the database for the given query."}, "json_schema": {"name": "response_format_schema", "schema": {"type": "object", "properties": {"status": {"type": "string", "enum": ["follow-up", "db-query", "validate-booking"]}, "details": {"oneOf": [{"type": "string", "description": "Details for follow-up/acknowledgement, if the status is 'follow-up'."}, {"type": "object", "description": "Details for db-query.", "properties": {"destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "arriveby": {"type": "string"}, "leaveat": {"type": "string"}, "duration": {"type": "string"}}, "additionalProperties": false}, {"type": "object", "description": "Parameters specific to validate-booking.", "properties": {"arriveby": {"type": "string"}, "bookpeople": {"type": "string", "enum": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, "day": {"type": "string", "enum": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, "departure": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "destination": {"type": "string", "enum": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, "leaveat": {"type": "string"}}, "required": ["arriveby", "bookpeople", "day", "departure", "destination", "leaveat"], "additionalProperties": false}]}}, "required": ["status", "details"]}}, "domain": "train", "domaindb_path": "games/dmsystem_monolithic_llm/resources/domains/en/train-dbase.db", "domain_schema": {"train": {"service_name": "train", "slots": [{"name": "arriveby", "is_categorical": false, "possible_values": []}, {"name": "departure", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "day", "is_categorical": true, "possible_values": ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"]}, {"name": "bookpeople", "is_categorical": true, "possible_values": ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "15"]}, {"name": "leaveat", "is_categorical": false, "possible_values": []}, {"name": "destination", "is_categorical": true, "possible_values": ["birmingham new street", "bishops stortford", "broxbourne", "cambridge", "ely", "kings lynn", "leicester", "london kings cross", "london liverpool street", "norwich", "peterborough", "stansted airport", "stevenage"]}, {"name": "trainid", "is_categorical": false, "possible_values": []}, {"name": "ref", "is_categorical": false, "possible_values": []}, {"name": "price", "is_categorical": false, "possible_values": []}, {"name": "duration", "is_categorical": false, "possible_values": []}], "description": "find trains that take you to places", "intents": [{"name": "find_train", "description": "search for trains that take you places", "is_transactional": false, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}, {"name": "book_train", "description": "book train tickets", "is_transactional": true, "required_slots": [], "optional_slots": {"train-destination": "dontcare", "train-arriveby": "dontcare", "train-departure": "dontcare", "train-day": "dontcare", "train-bookpeople": "dontcare", "train-leaveat": "dontcare"}}]}}, "goal": "I am looking for a train leaving London Kings Cross and arriving by 14:30.", "slots": {"arriveby": "14:30", "bookpeople": "7", "day": "thursday", "departure": "london kings cross", "destination": "cambridge", "leaveat": "10"}, "cat_slots": ["departure", "day", "bookpeople", "destination"], "noncat_slots": ["arriveby", "leaveat", "trainid", "ref", "price", "duration"], "game_name": "dmsystem_modular_prog", "domaindbkeys": ["destination", "day", "departure", "arriveby", "leaveat", "duration"], "prompt_a": "ROLE: You are a system tasked with interacting naturally with a train booking system.\n\nTASK:\nI am looking for a train leaving London Kings Cross and arriving by 14:30.\n\nINSTRUCTIONS:\n1. Begin the conversation by repeating the task exactly as written under the label TASK. Do not add any other text, commentary, or explanations.\n2. Communicate naturally by expressing preferences, asking clarifying questions, and making decisions as needed during the interaction. Ensure the tone is polite and conversational.\n3. Respond strictly based on the 'response' provided by the booking system. Use no additional logic or interpretation beyond what is explicitly stated in the task.\n4. Once the booking system completes the task and provides the booking reference number, respond with \"DONE.\" No other text should follow.\n5. Do not attempt to simulate or act as the booking system; you are only interacting with it.\n6. Keep responses concise and focused, avoiding unnecessary elaboration or overly conversational tone.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '14:30', 'bookpeople': '7', 'day': 'thursday', 'departure': 'london kings cross', 'destination': 'cambridge', 'leaveat': '10'}\n\nOUTPUT FORMAT:\n1. When beginning: Repeat the TASK exactly as stated.\n2. When interacting: Provide appropriate conversational utterances based solely on the booking system's 'response.'\n3. For the booking system's queries, strictly use the information under TASK DETAILS.\n4. When the booking is complete: Respond with \"DONE\"\n\n\nLets begin\n", "turn_prompt_a": "1. Continue interacting until the task is complete.\n2. Once the booking system completes the task and provides the booking reference number, respond with \"DONE\".\n3. Do not simulate or act as the booking system; you are only interacting with it.\n4. For the booking system's queries, strictly use the information under TASK DETAILS.\n\nTASK DETAILS:\nUse the following details to provide information during the conversation:\n{'arriveby': '14:30', 'bookpeople': '7', 'day': 'thursday', 'departure': 'london kings cross', 'destination': 'cambridge', 'leaveat': '10'}\n\nHere is the train booking system response:", "prompt_b": "ROLE: You are the dialogue manager for a train booking bot. Your role is to process user requests, coordinate interactions with subsystems, and ensure successful task completion.\n\nAVAILABLE SUBSYSTEMS:\n1. Intent Detector: Identifies the user's intent (e.g., inquiry, clarification, or booking).\n2. Slot Extractor: Extracts key details needed for the task (e.g., date, time, location).\n3. Follow-up Generator: Generates responses to gather missing/unclear information or provide booking status.\n4. Booking Aggregator: Consolidates all extracted and clarified details for booking finalization.\n\nSUBSYSTEM NAMING CONVENTIONS:\nFor all sub-system interactions, use these exact names:\n   {\n      Intent Detector = \"intent_detector\"\n      Slot Extractor = \"slot_extractor\"\n      Follow-up Generator = \"followup_generator\"\n      Booking Aggregator = \"booking_aggregator\"\n   }\n\n\nTASK FLOWS:\n1. Information/Query Flow:\n   - Use subsystems 1-3 when the user is:\n     * Asking for information\n     * Making inquiries\n     * Providing partial information\n     * Needs clarification or follow-up questions\n\n2. Booking Flow:\n   - Use subsystem 4 for gathering and consolidating booking information\n     * All required booking information is available\n     * User's intent is clearly to make a booking\n     * Previous clarifications or follow-ups have been resolved\n     * Return to subsystem 4 based on booking confirmation outcome\n\nTASK:\n1. For each user request:\n   a. Determine appropriate flow based on user intent and available information\n   b. Identify next required subsystem\n   c. Prepare the necessary input data for that subsystem\n2. \"db-query\" and \"validate-booking\" are the external systems. Do not treat them as sub-systems.\n\nINTERMEDIATE RESPONSE FORMAT:\nDuring task progression, when calling the next subsystem:\n{\n   \"next_subsystem\": \"SUBSYSTEM_NAME\",\n   \"input_data\": {\n      \"field_1\": \"value_1\",\n      \"field_2\": \"value_2\"\n      // Include all relevant data for the chosen subsystem\n   }\n}\n\nFINAL RESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nNOTES:\n1. Always use the exact subsystem names as specified.\n2. Ensure seamless coordination between subsystems to achieve task completion.\n\n\nUSER REQUEST:", "turn_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nFINAL RESPONSE FORMAT(upon task completion):\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nUSER REQUEST:", "dbquery_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nDATABASE RETRIEVAL RESULTS:", "validbooking_prompt_b": "TASK:\n1. Review the previous state and new user input\n2. Update the conversation flow if necessary\n3. Identify missing or unclear information\n4. Select the next appropriate subsystem based on:\n   * Current flow status\n   * Completeness of required information\n   * Previous subsystem results\n   * User's latest input\n\nRESPONSE FORMAT:\n1. For proceeding with the booking:\n{\n   \"status\": \"validate-booking\",\n   \"details\": {FILLED SLOTS}\n}\n\n2. For follow-up (The FOLLOW-UP MESSAGE must be a concise string.):\n{\n   \"status\": \"follow-up\",\n   \"details\": FOLLOW-UP MESSAGE\n}\n\n3. For querying the database:\n{\n   \"status\": \"db-query\",\n   \"details\": {FILLED SLOTS}\n}\n\nBOOKING VALIDATION STATUS:", "turn_ss_prompt_b": "Response received from the $sub-system sub-system:", "intent_detection": "ROLE: You are an Intent Detection system designed to classify user requests into predefined intents.\n\nAVAILABLE INTENTS:\nFor all intent detections, use these exact names:\n1. booking-request: User wants to proceed with the booking.\n2. booking-success: The booking was successful and has some booking number.\n3. booking-failure: There is a failure in the booking.\n4. dbretrieval-request: User is looking for some information.\n5. dbretrieval-success: The DB retrieval was successful.\n6. dbretrieval-failure: There is a failure in the DB retrieval.\n7. detection-unknown: If the input doesn't fall into any of the above\n\n\nTASK:\n1. Analyze the provided user request.\n2. Classify the request into only one of the above predefined intents (the closest match)\n3. Return the detected intent by using those exact names.\n4. Do not add any other information.\n\nRESPONSE FORMAT:\n{\n    \"intent_detection\": \"DETECTED_INTENT\"\n}\n\nUSER REQUEST:", "slot_extraction": "ROLE: You are an Slot Extraction system designed to identify and extract key entities from user requests to support downstream tasks.\n\nTASK:\n1. Analyze the provided user request.\n2. Identify and extract relevant slots (e.g., name, area, time, date, type of cuisine, number of people, type of hotel) based on the task context.\n3. Focus on extracting the most concise and precise values for each slot, avoiding unnecessary descriptive phrases or additional words.\n4. Return the extracted slots in a structured format.\n5. Do not add any other information.\n6. Use the following slot names to extract relevant information:\n['arriveby', 'bookpeople', 'day', 'departure', 'destination', 'leaveat']\n\nRESPONSE FORMAT:\n{\n    \"slot_extraction\": {\n        \"slot1\": \"value1\",\n        \"slot2\": \"value2\",\n        ...\n    }\n}\n\nUSER REQUEST:", "followup_generation": "ROLE: You are a Follow-up Generation system responsible for crafting contextually appropriate and concise replies based strictly on the provided input.\n\nTASK:\nGiven the input data (intent, extracted slots, database (DB) information, and additional context):\n1. Generate a meaningful follow-up:\n   a. If additional information is required to proceed, respond conversationally using direct and focused phrasing.\n   b. If recommendations are provided in the DB:\n      * Ask the user to choose from the list of options.\n      * Clearly present all options to the user for selection. Do not decide on any recommendation yourself.\n\n2. Ensure Slot Completion:\n['arriveby', 'bookpeople', 'day', 'departure', 'destination', 'leaveat']\n   a. In the course of the conversation, ensure that all required slots are captured or addressed.\n   b. If any slots are missing, generate a follow-up question to collect the necessary information.\n   c. No need to query information other than the required slots\n\n3. Guidelines for Response:\n   a. Responses must be concise and to the point.\n   b. Avoid unnecessary elaboration or an overly conversational tone.\n   c. Do not generate or fabricate any information that is not explicitly present in the DB or provided input.\n   d. Do not generate any booking confirmations on your own.\n   e. If the input contains booking confirmation, share the same without any changes.\n\n\nRESPONSE FORMAT:\n{\n    \"followup_generation\": GENERATED_RESPONSE\n}\n\nINPUT:", "dbquery_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for database retrieval based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'arriveby': {'type': 'string'}, 'leaveat': {'type': 'string'}, 'duration': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"dbquery_format\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:", "booking_formatter": "ROLE: You are a formatter system responsible for preparing a dictionary for booking confirmation based on intent and extracted entities.\n\nInstructions:\n1. Validate the input using the provided JSON schema.\n2. Use the extracted slots from the user request and map them to the corresponding keys in the schema.\n3. Ensure all values conform to the types and possible values defined in the schema.\n4. When mapping values to keys with predefined valid values (e.g., parking/internet), infer the most appropriate match even if the input value is slightly different. For example:\n   a. Map 'free' to 'yes' for parking, as 'free' implies availability.\n   b. Map 'wifi' to 'yes' for internet, as 'wifi' implies need for internet.\n   b. Use predefined schema constraints to guide mappings for all other values.\n6. Do not add any other information or comments.\n\nJSON schema:\n{'arriveby': {'type': 'string'}, 'bookpeople': {'type': 'string', 'enum': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '15']}, 'day': {'type': 'string', 'enum': ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']}, 'departure': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'destination': {'type': 'string', 'enum': ['birmingham new street', 'bishops stortford', 'broxbourne', 'cambridge', 'ely', 'kings lynn', 'leicester', 'london kings cross', 'london liverpool street', 'norwich', 'peterborough', 'stansted airport', 'stevenage']}, 'leaveat': {'type': 'string'}}\n\nRESPONSE FORMAT:\n{\n    \"booking_query\": {\n        // Consolidated dictionary\n    }\n}\n\nINPUT:"}}]}]}